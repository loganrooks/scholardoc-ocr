---
phase: 03-ocr-backend-modules
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scholardoc_ocr/tesseract.py
  - tests/test_tesseract.py
autonomous: true

must_haves:
  truths:
    - "Tesseract OCR can be invoked via tesseract.run_ocr() without PDFProcessor"
    - "ocrmypdf Python API used instead of subprocess"
    - "Configurable timeout with sensible default"
    - "Lazy import of ocrmypdf (not at module level)"
    - "is_available() checks Tesseract dependency without side effects"
  artifacts:
    - path: "src/scholardoc_ocr/tesseract.py"
      provides: "Tesseract OCR backend module"
      exports: ["run_ocr", "TesseractConfig", "TesseractResult", "is_available"]
    - path: "tests/test_tesseract.py"
      provides: "Unit tests for Tesseract backend"
      min_lines: 60
  key_links:
    - from: "src/scholardoc_ocr/tesseract.py"
      to: "ocrmypdf.ocr()"
      via: "lazy import inside run_ocr()"
      pattern: "ocrmypdf\\.ocr\\("
---

<objective>
Create the Tesseract OCR backend module as a stateless function module wrapping ocrmypdf's Python API, with config/result dataclasses, lazy imports, and unit tests.

Purpose: Isolate Tesseract operations from PDFProcessor so they can be tested and used independently.
Output: tesseract.py module + test_tesseract.py
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ocr-backend-modules/03-RESEARCH.md
@src/scholardoc_ocr/processor.py
@src/scholardoc_ocr/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tesseract.py backend module</name>
  <files>src/scholardoc_ocr/tesseract.py</files>
  <action>
Create `src/scholardoc_ocr/tesseract.py` as a function-based module (no class). Include:

1. **TesseractConfig dataclass** with fields:
   - `langs: list[str]` (default `["eng", "fra", "ell", "lat"]`)
   - `jobs: int = 4`
   - `timeout: float = 600.0` (per-page tesseract_timeout in seconds)
   - `skip_big: int = 100` (megapixels threshold)

2. **TesseractResult dataclass** with fields:
   - `success: bool`
   - `output_path: Path | None = None`
   - `error: str | None = None`

3. **`run_ocr(input_path: Path, output_path: Path, config: TesseractConfig) -> TesseractResult`**
   - Lazy-import `ocrmypdf` inside the function body (NOT at module level)
   - Use `ocrmypdf.ocr()` Python API (NOT subprocess) with parameters:
     - `language=config.langs` (list form)
     - `redo_ocr=True`, `clean=True`, `output_type="pdfa"`
     - `jobs=config.jobs`, `tesseract_timeout=config.timeout`
     - `skip_big=config.skip_big`, `progress_bar=False`
   - Return `TesseractResult(success=True, output_path=output_path)` when `ocrmypdf.ocr()` returns `ExitCode.ok` (value 0)
   - Catch `ocrmypdf.exceptions.PriorOcrFoundError` -> return success (already has OCR)
   - Catch `ocrmypdf.exceptions.MissingDependencyError` -> return failure with descriptive error
   - Catch general `Exception` -> return failure with error string
   - Use `from __future__ import annotations` for deferred type evaluation

4. **`is_available() -> bool`**
   - Check if ocrmypdf can be imported without side effects
   - Use try/except ImportError pattern

Use `logging.getLogger(__name__)` for logging. Follow existing module patterns from quality.py.
  </action>
  <verify>
Run `python -c "from scholardoc_ocr.tesseract import run_ocr, TesseractConfig, TesseractResult, is_available; print('OK')"` — should print OK without importing torch or loading ML models.

Run `python -c "import time; t=time.time(); from scholardoc_ocr.tesseract import is_available; print(f'Import took {time.time()-t:.2f}s')"` — should be under 0.5s (no heavy imports at module level).
  </verify>
  <done>tesseract.py exists with run_ocr, TesseractConfig, TesseractResult, is_available exports. ocrmypdf imported lazily inside function bodies only. No torch/marker imports anywhere in the module.</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for tesseract backend</name>
  <files>tests/test_tesseract.py</files>
  <action>
Create `tests/test_tesseract.py` with unit tests that mock ocrmypdf (no real OCR needed):

1. **test_run_ocr_success** — Mock `ocrmypdf.ocr` to return 0, verify TesseractResult.success is True and output_path is set.

2. **test_run_ocr_prior_ocr** — Mock `ocrmypdf.ocr` to raise `PriorOcrFoundError`, verify result is still success=True (pre-existing OCR is fine).

3. **test_run_ocr_failure** — Mock `ocrmypdf.ocr` to raise an Exception, verify success=False and error is populated.

4. **test_run_ocr_missing_dependency** — Mock `ocrmypdf.ocr` to raise `MissingDependencyError`, verify success=False with descriptive error.

5. **test_config_defaults** — Verify TesseractConfig default values (langs, jobs, timeout, skip_big).

6. **test_is_available** — Test is_available returns bool without errors.

7. **test_lazy_import** — Verify `ocrmypdf` is NOT in `sys.modules` after importing `tesseract` module (only after calling `run_ocr`).

Use `unittest.mock.patch` to mock `ocrmypdf` inside the tesseract module. Use `tmp_path` fixture for file paths. Follow test patterns from existing test_quality.py.

Add `@pytest.mark.integration` marker stub comment for future real-PDF integration tests (do not implement integration tests — those need real Tesseract installed).
  </action>
  <verify>Run `pytest tests/test_tesseract.py -v` — all tests pass.</verify>
  <done>7+ unit tests pass, all mocked (no real OCR invocation). Lazy import verified. Integration test marker documented for future use.</done>
</task>

</tasks>

<verification>
1. `python -c "from scholardoc_ocr.tesseract import run_ocr, TesseractConfig, TesseractResult, is_available"` succeeds
2. `pytest tests/test_tesseract.py -v` — all tests pass
3. `ruff check src/scholardoc_ocr/tesseract.py tests/test_tesseract.py` — no lint errors
4. No `import ocrmypdf` at module level in tesseract.py (only inside function bodies)
</verification>

<success_criteria>
- Tesseract backend module exists and can be imported independently
- Uses ocrmypdf Python API (not subprocess)
- All imports are lazy (no heavy deps at module level)
- Unit tests pass with mocked ocrmypdf
- Lint clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-ocr-backend-modules/03-01-SUMMARY.md`
</output>
