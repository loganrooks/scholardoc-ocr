---
phase: 03-ocr-backend-modules
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scholardoc_ocr/surya.py
  - tests/test_surya.py
autonomous: true

must_haves:
  truths:
    - "Surya models can be loaded once via load_models() and reused across convert_pdf() calls"
    - "convert_pdf() accepts pre-loaded model_dict (no per-call model loading)"
    - "All torch/marker imports are lazy (inside function bodies only)"
    - "is_available() checks Marker dependency without importing torch"
    - "Configurable timeouts for model loading and batch processing"
  artifacts:
    - path: "src/scholardoc_ocr/surya.py"
      provides: "Surya/Marker OCR backend module with model lifecycle"
      exports: ["load_models", "convert_pdf", "SuryaConfig", "is_available"]
    - path: "tests/test_surya.py"
      provides: "Unit tests for Surya backend"
      min_lines: 60
  key_links:
    - from: "src/scholardoc_ocr/surya.py"
      to: "marker.models.create_model_dict"
      via: "lazy import inside load_models()"
      pattern: "create_model_dict"
    - from: "src/scholardoc_ocr/surya.py"
      to: "marker.converters.pdf.PdfConverter"
      via: "lazy import inside convert_pdf()"
      pattern: "PdfConverter"
---

<objective>
Create the Surya/Marker OCR backend module with explicit model lifecycle management, lazy imports, and unit tests.

Purpose: Isolate Surya operations from PDFProcessor with proper model loading (once per pipeline run) and conversion functions.
Output: surya.py module + test_surya.py
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ocr-backend-modules/03-RESEARCH.md
@src/scholardoc_ocr/processor.py
@src/scholardoc_ocr/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create surya.py backend module</name>
  <files>src/scholardoc_ocr/surya.py</files>
  <action>
Create `src/scholardoc_ocr/surya.py` as a function-based module. Include:

1. **SuryaConfig dataclass** with fields:
   - `langs: str = "en,fr,el,la"`
   - `force_ocr: bool = True`
   - `batch_size: int = 50`
   - `model_load_timeout: float = 300.0` (seconds, for model loading)
   - `batch_timeout: float = 1200.0` (seconds, per batch)

2. **`load_models(device: str | None = None) -> dict[str, Any]`**
   - Lazy-import `marker.models.create_model_dict` inside function body
   - If device is specified, lazy-import torch and pass `torch.device(device)`
   - Otherwise call `create_model_dict()` with defaults
   - Log model loading start/completion
   - On failure, raise `OCRBackendError` from exceptions.py (or RuntimeError if exceptions module doesn't have it — check first)

3. **`convert_pdf(input_path: Path, model_dict: dict[str, Any], config: SuryaConfig, page_range: list[int] | None = None) -> str`**
   - Lazy-import `PdfConverter` and `text_from_rendered` inside function body
   - Create converter with `artifact_dict=model_dict` and config dict from SuryaConfig
   - If `page_range` is provided, include it in config
   - Run converter on input_path
   - Return the rendered markdown text
   - On failure, raise with descriptive error

4. **`is_available() -> bool`**
   - Use `importlib.import_module("marker")` — does NOT import torch
   - Return True/False based on ImportError

Use `from __future__ import annotations` and `TYPE_CHECKING` for type hints. Use `logging.getLogger(__name__)`. All torch/marker imports MUST be inside function bodies only.
  </action>
  <verify>
Run `python -c "from scholardoc_ocr.surya import load_models, convert_pdf, SuryaConfig, is_available; print('OK')"` — should print OK fast (no torch/marker loaded).

Run `python -c "import sys; from scholardoc_ocr.surya import SuryaConfig; assert 'torch' not in sys.modules; assert 'marker' not in sys.modules; print('Lazy OK')"` — confirms no heavy imports at module level.
  </verify>
  <done>surya.py exists with load_models, convert_pdf, SuryaConfig, is_available exports. Model loading separated from conversion. All ML imports lazy.</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for surya backend</name>
  <files>tests/test_surya.py</files>
  <action>
Create `tests/test_surya.py` with unit tests that mock marker/torch (no real ML models needed):

1. **test_load_models_success** — Mock `marker.models.create_model_dict` to return a fake dict. Verify load_models() returns it.

2. **test_load_models_with_device** — Mock both torch and create_model_dict. Verify device is passed through as torch.device.

3. **test_load_models_failure** — Mock create_model_dict to raise RuntimeError. Verify exception propagates.

4. **test_convert_pdf_success** — Mock PdfConverter and text_from_rendered. Verify convert_pdf returns text string with model_dict passed through as artifact_dict.

5. **test_convert_pdf_with_page_range** — Mock PdfConverter. Verify page_range is included in config when provided.

6. **test_config_defaults** — Verify SuryaConfig default values (langs, force_ocr, batch_size, timeouts).

7. **test_is_available** — Test is_available returns bool without importing torch.

8. **test_lazy_imports** — Verify `torch` and `marker` are NOT in `sys.modules` after importing the surya module (only after calling load_models).

Use `unittest.mock.patch` to mock marker and torch modules. Use `tmp_path` fixture. Follow existing test patterns.

Add `@pytest.mark.integration` comment stubs for future integration tests requiring real Surya models.
  </action>
  <verify>Run `pytest tests/test_surya.py -v` — all tests pass.</verify>
  <done>8+ unit tests pass, all mocked (no real model loading). Lazy import verified. Model dict reuse pattern tested.</done>
</task>

</tasks>

<verification>
1. `python -c "from scholardoc_ocr.surya import load_models, convert_pdf, SuryaConfig, is_available"` succeeds
2. `pytest tests/test_surya.py -v` — all tests pass
3. `ruff check src/scholardoc_ocr/surya.py tests/test_surya.py` — no lint errors
4. No `import torch` or `import marker` at module level in surya.py
5. `torch` not in sys.modules after `from scholardoc_ocr.surya import SuryaConfig`
</verification>

<success_criteria>
- Surya backend module exists with separate load_models and convert_pdf functions
- Model dict loaded once, passed into convert_pdf (not loaded per call)
- All ML imports lazy (torch, marker not at module level)
- Unit tests pass with mocked marker/torch
- Lint clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-ocr-backend-modules/03-02-SUMMARY.md`
</output>
