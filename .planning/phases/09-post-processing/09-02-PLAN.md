---
phase: 09-post-processing
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/scholardoc_ocr/pipeline.py
autonomous: true

must_haves:
  truths:
    - "Text written to .txt files in final/ has been post-processed"
    - "Post-processing runs on both existing-text and Tesseract-output paths"
    - "Surya text replacement also gets post-processed"
  artifacts:
    - path: "src/scholardoc_ocr/pipeline.py"
      provides: "Pipeline with postprocess integration"
      contains: "from .postprocess import postprocess"
  key_links:
    - from: "src/scholardoc_ocr/pipeline.py"
      to: "src/scholardoc_ocr/postprocess.py"
      via: "postprocess() called before writing .txt files"
      pattern: "postprocess\\(full_text\\)"
---

<objective>
Integrate postprocess() into the pipeline so all text output is post-processed before writing to disk.

Purpose: Wire the transforms into the actual OCR pipeline at all text output points.
Output: Updated pipeline.py that produces RAG-ready text.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@src/scholardoc_ocr/pipeline.py
@.planning/phases/09-post-processing/09-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate postprocess into pipeline text output</name>
  <files>src/scholardoc_ocr/pipeline.py</files>
  <action>
In `_tesseract_worker()`, add `from .postprocess import postprocess` at the top of the function (alongside other lazy imports).

Apply postprocess to text before writing .txt files at these 3 locations:

1. **Existing text path (line ~94):** Change `full_text = "\n\n".join(page_texts)` to:
   ```python
   full_text = postprocess("\n\n".join(page_texts))
   ```

2. **Tesseract output path (line ~164):** Same change:
   ```python
   full_text = postprocess("\n\n".join(tess_page_texts))
   ```

3. **Surya text replacement in run_pipeline (line ~420-432):** After Surya replaces page texts and before writing, apply postprocess to the rejoined text:
   ```python
   text_path.write_text(
       postprocess("\n\n".join(page_texts)), encoding="utf-8"
   )
   ```

Do NOT change PageResult.text fields -- those store raw per-page text for quality analysis. Only post-process the final .txt file output.
  </action>
  <verify>
- `ruff check src/scholardoc_ocr/pipeline.py` -- no lint errors
- `python -c "from scholardoc_ocr.pipeline import _tesseract_worker"` -- no import errors
- `pytest` -- existing tests still pass (ignore pre-existing test_callbacks.py collection error)
  </verify>
  <done>All 3 text output points in pipeline.py call postprocess() before writing to disk</done>
</task>

</tasks>

<verification>
- `ruff check src/` -- clean
- `pytest tests/test_postprocess.py` -- all pass
- `pytest` -- no regressions (excluding known test_callbacks.py issue)
- grep confirms postprocess called at all 3 write points: `grep -n "postprocess" src/scholardoc_ocr/pipeline.py`
</verification>

<success_criteria>
- pipeline.py imports and calls postprocess() at all 3 text output locations
- No lint errors, no test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/09-post-processing/09-02-SUMMARY.md`
</output>
