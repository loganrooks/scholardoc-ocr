---
phase: 01-foundation-and-data-structures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scholardoc_ocr/types.py
  - src/scholardoc_ocr/callbacks.py
  - src/scholardoc_ocr/exceptions.py
autonomous: true

must_haves:
  truths:
    - "Library has structured result types with per-file and per-page detail"
    - "Progress callbacks use Protocol (decoupled from Rich)"
    - "Exception hierarchy exists for all error categories"
    - "All new types are JSON-serializable via to_dict/to_json"
  artifacts:
    - path: "src/scholardoc_ocr/types.py"
      provides: "BatchResult, FileResult, PageResult, OCREngine enum, ProcessingPhase enum"
      contains: "class BatchResult"
    - path: "src/scholardoc_ocr/callbacks.py"
      provides: "PipelineCallback Protocol, LoggingCallback, ProgressEvent, PhaseEvent, ModelEvent"
      contains: "class PipelineCallback"
    - path: "src/scholardoc_ocr/exceptions.py"
      provides: "ScholarDocError, OCRError, PDFError, ConfigError, DependencyError"
      contains: "class ScholarDocError"
  key_links:
    - from: "src/scholardoc_ocr/types.py"
      to: "json"
      via: "to_dict and to_json methods"
      pattern: "def to_json"
---

<objective>
Create the three new leaf modules that define the library's API contracts: result types, callback protocol, and exception hierarchy.

Purpose: These modules are the foundation all other phases build on. They define the structured data shapes, progress reporting interface, and error handling contracts. They are leaf modules with no internal imports (preventing circular dependencies).

Output: Three new Python modules in src/scholardoc_ocr/
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-data-structures/01-CONTEXT.md
@.planning/phases/01-foundation-and-data-structures/01-RESEARCH.md
@src/scholardoc_ocr/processor.py
@src/scholardoc_ocr/pipeline.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types.py — Result dataclasses and enums</name>
  <files>src/scholardoc_ocr/types.py</files>
  <action>
Create `src/scholardoc_ocr/types.py` with these components (all using Python 3.11+ stdlib only):

**Enums (StrEnum for JSON compatibility):**
- `OCREngine(StrEnum)`: `TESSERACT = "tesseract"`, `SURYA = "surya"`, `EXISTING = "existing"`, `NONE = "none"`
- `ProcessingPhase(StrEnum)`: `ANALYSIS = "analysis"`, `TESSERACT = "tesseract"`, `SURYA = "surya"`
- `PageStatus(StrEnum)`: `GOOD = "good"`, `FLAGGED = "flagged"`, `ERROR = "error"`

**Dataclasses (drill-in model: BatchResult > FileResult > PageResult):**

`PageResult`:
- Fields: `page_number: int`, `status: PageStatus`, `quality_score: float`, `engine: OCREngine`, `flagged: bool = False`, `text: str | None = None` (optional, not included in to_dict by default)
- Method: `to_dict(include_text: bool = False) -> dict`

`FileResult`:
- Fields: `filename: str`, `success: bool`, `engine: OCREngine`, `quality_score: float`, `page_count: int`, `pages: list[PageResult]`, `error: str | None = None`, `time_seconds: float = 0.0`, `phase_timings: dict[str, float] = field(default_factory=dict)`
- Properties: `flagged_pages -> list[PageResult]` (filter pages where flagged=True), `page_scores -> list[float]`
- Method: `to_dict(include_text: bool = False) -> dict`

`BatchResult`:
- Fields: `files: list[FileResult]`, `total_time_seconds: float = 0.0`, `config: dict = field(default_factory=dict)`
- Properties: `success_count -> int`, `error_count -> int`, `flagged_count -> int` (files with any flagged pages)
- Methods: `to_dict(include_text: bool = False) -> dict`, `to_json(include_text: bool = False, indent: int = 2) -> str` (uses json.dumps)

All `to_dict` methods must produce plain dicts/lists/strings/numbers (JSON-serializable). Enums serialize as their string value. Use `from __future__ import annotations` for forward refs. NO internal imports — this is a leaf module.
  </action>
  <verify>
Run: `python -c "from scholardoc_ocr.types import BatchResult, FileResult, PageResult, OCREngine; import json; pr = PageResult(page_number=1, status='good', quality_score=0.95, engine='tesseract'); fr = FileResult(filename='test.pdf', success=True, engine='tesseract', quality_score=0.95, page_count=1, pages=[pr]); br = BatchResult(files=[fr]); print(br.to_json())"`
Must print valid JSON with nested structure.
  </verify>
  <done>types.py exists with BatchResult > FileResult > PageResult drill-in model, all JSON-serializable via to_dict/to_json, using StrEnum for enums</done>
</task>

<task type="auto">
  <name>Task 2: Create callbacks.py — Progress callback protocol and events</name>
  <files>src/scholardoc_ocr/callbacks.py</files>
  <action>
Create `src/scholardoc_ocr/callbacks.py` with:

**Event dataclasses:**
- `ProgressEvent`: `phase: str`, `current: int`, `total: int`, `filename: str | None = None`, `worker_id: int | None = None`, `eta_seconds: float | None = None`
- `PhaseEvent`: `phase: str`, `status: str` (starting/complete), `files_count: int = 0`, `pages_count: int = 0`
- `ModelEvent`: `model_name: str`, `status: str` (loading/loaded/failed), `time_seconds: float | None = None`

**Protocol (runtime_checkable):**
```python
@runtime_checkable
class PipelineCallback(Protocol):
    def on_progress(self, event: ProgressEvent) -> None: ...
    def on_phase(self, event: PhaseEvent) -> None: ...
    def on_model(self, event: ModelEvent) -> None: ...
```

**LoggingCallback (concrete implementation):**
- Implements PipelineCallback using Python `logging` module
- `on_progress`: logs at DEBUG level
- `on_phase`: logs at INFO level
- `on_model`: logs at INFO level
- Constructor takes optional `logger: logging.Logger` parameter

**NullCallback (no-op implementation):**
- All methods are no-ops (pass)
- Used as default when no callback provided

NO internal imports — leaf module. Use `from __future__ import annotations`. Use `typing.Protocol` and `typing.runtime_checkable`.
  </action>
  <verify>
Run: `python -c "from scholardoc_ocr.callbacks import PipelineCallback, LoggingCallback, NullCallback, ProgressEvent; cb = LoggingCallback(); cb.on_progress(ProgressEvent(phase='tesseract', current=1, total=10)); print('OK'); print(isinstance(cb, PipelineCallback))"`
Must print OK and True.
  </verify>
  <done>callbacks.py exists with PipelineCallback Protocol, LoggingCallback, NullCallback, and typed event dataclasses</done>
</task>

<task type="auto">
  <name>Task 3: Create exceptions.py — Exception hierarchy</name>
  <files>src/scholardoc_ocr/exceptions.py</files>
  <action>
Create `src/scholardoc_ocr/exceptions.py` with:

**Exception hierarchy:**
```
ScholarDocError (base, extends Exception)
├── OCRError (OCR engine failures)
│   ├── TesseractError
│   └── SuryaError
├── PDFError (PDF read/write failures)
├── ConfigError (invalid configuration)
└── DependencyError (missing external dependency like marker-pdf, ocrmypdf)
```

Each exception class:
- `ScholarDocError`: accepts `message: str`, optional `details: dict | None = None`. Stores both as attributes. `__str__` returns message.
- `OCRError`: adds `filename: str | None = None` attribute
- `TesseractError` and `SuryaError`: inherit from OCRError, no additional fields
- `PDFError`: adds `pdf_path: str | None = None` attribute
- `ConfigError`: adds `parameter: str | None = None` attribute
- `DependencyError`: adds `package: str | None = None`, `install_hint: str | None = None` attributes

NO internal imports — leaf module.
  </action>
  <verify>
Run: `python -c "from scholardoc_ocr.exceptions import ScholarDocError, OCRError, TesseractError, SuryaError, PDFError, ConfigError, DependencyError; e = DependencyError('marker not found', package='marker-pdf', install_hint='pip install marker-pdf'); print(e, e.package); raise TesseractError('timeout', filename='test.pdf')" 2>&1 | tail -1`
Must show TesseractError with message.
  </verify>
  <done>exceptions.py exists with full exception hierarchy, each with relevant contextual attributes</done>
</task>

</tasks>

<verification>
1. All three modules import without error: `python -c "from scholardoc_ocr import types, callbacks, exceptions"`
2. No internal imports in any new module (leaf modules only)
3. `ruff check src/scholardoc_ocr/types.py src/scholardoc_ocr/callbacks.py src/scholardoc_ocr/exceptions.py` passes
4. BatchResult.to_json() produces valid JSON
5. LoggingCallback satisfies PipelineCallback Protocol check
</verification>

<success_criteria>
- Three new modules exist: types.py, callbacks.py, exceptions.py
- All use Python 3.11+ stdlib only (dataclasses, StrEnum, Protocol)
- Zero internal imports (leaf modules)
- Result types are JSON-serializable
- Callback protocol is runtime-checkable
- ruff passes on all new files
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-data-structures/01-01-SUMMARY.md`
</output>
