---
phase: 01-foundation-and-data-structures
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/scholardoc_ocr/__init__.py
  - tests/test_types.py
  - tests/test_processor.py
  - tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "Unit tests verify result type serialization"
    - "Unit tests verify PDF processor operations with context managers"
    - "Public API is re-exported from __init__.py"
    - "Tests pass with pytest"
  artifacts:
    - path: "tests/test_types.py"
      provides: "Tests for BatchResult, FileResult, PageResult serialization"
      contains: "def test_"
    - path: "tests/test_processor.py"
      provides: "Tests for extract_text, extract_pages, context manager safety"
      contains: "def test_"
    - path: "tests/conftest.py"
      provides: "Shared fixtures (sample PDF creation)"
      contains: "def sample_pdf"
    - path: "src/scholardoc_ocr/__init__.py"
      provides: "Public API re-exports"
      contains: "from .types import"
  key_links:
    - from: "tests/test_processor.py"
      to: "src/scholardoc_ocr/processor.py"
      via: "imports PDFProcessor"
      pattern: "from scholardoc_ocr.processor import"
    - from: "src/scholardoc_ocr/__init__.py"
      to: "src/scholardoc_ocr/types.py"
      via: "re-exports result types"
      pattern: "from \\.types import"
---

<objective>
Wire up public API re-exports in __init__.py and create unit tests for the new types and cleaned-up processor.

Purpose: Validates that Plan 01 (types/callbacks/exceptions) and Plan 02 (cleanup) work correctly. Establishes the test infrastructure for all future phases.

Output: Test suite and public API surface
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-data-structures/01-CONTEXT.md
@.planning/phases/01-foundation-and-data-structures/01-01-SUMMARY.md
@.planning/phases/01-foundation-and-data-structures/01-02-SUMMARY.md
@src/scholardoc_ocr/__init__.py
@src/scholardoc_ocr/types.py
@src/scholardoc_ocr/callbacks.py
@src/scholardoc_ocr/exceptions.py
@src/scholardoc_ocr/processor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire __init__.py public API and create test infrastructure</name>
  <files>src/scholardoc_ocr/__init__.py, tests/conftest.py, tests/__init__.py</files>
  <action>
**__init__.py — Add public API re-exports:**

Keep existing docstring and __version__. Add re-exports:

```python
from .types import (
    BatchResult, FileResult, PageResult,
    OCREngine, ProcessingPhase, PageStatus,
)
from .callbacks import PipelineCallback, LoggingCallback, NullCallback
from .exceptions import (
    ScholarDocError, OCRError, TesseractError, SuryaError,
    PDFError, ConfigError, DependencyError,
)

__all__ = [
    "__version__",
    "BatchResult", "FileResult", "PageResult",
    "OCREngine", "ProcessingPhase", "PageStatus",
    "PipelineCallback", "LoggingCallback", "NullCallback",
    "ScholarDocError", "OCRError", "TesseractError", "SuryaError",
    "PDFError", "ConfigError", "DependencyError",
]
```

**tests/__init__.py** — Create empty file.

**tests/conftest.py — Shared fixtures:**

```python
import pytest
from pathlib import Path

@pytest.fixture
def sample_pdf(tmp_path):
    """Create a minimal valid PDF for testing."""
    import fitz
    doc = fitz.open()
    page = doc.new_page()
    page.insert_text((72, 72), "This is test content on page one.")
    page2 = doc.new_page()
    page2.insert_text((72, 72), "This is test content on page two.")
    pdf_path = tmp_path / "test.pdf"
    doc.save(pdf_path)
    doc.close()
    return pdf_path

@pytest.fixture
def empty_pdf(tmp_path):
    """Create a PDF with no text content."""
    import fitz
    doc = fitz.open()
    doc.new_page()
    pdf_path = tmp_path / "empty.pdf"
    doc.save(pdf_path)
    doc.close()
    return pdf_path
```
  </action>
  <verify>
Run: `python -c "from scholardoc_ocr import BatchResult, PipelineCallback, ScholarDocError; print('public API OK')"`
Run: `python -c "import scholardoc_ocr; print(scholardoc_ocr.__all__)"` — must list all exports
  </verify>
  <done>__init__.py re-exports all public types, test infrastructure exists with PDF fixtures</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for types and processor</name>
  <files>tests/test_types.py, tests/test_processor.py</files>
  <action>
**tests/test_types.py — Test result type serialization and structure:**

Test cases:
- `test_page_result_to_dict`: Create PageResult, verify to_dict produces correct keys/values, verify text excluded by default
- `test_page_result_to_dict_with_text`: Verify include_text=True includes text field
- `test_file_result_to_dict`: Create FileResult with pages, verify nested serialization
- `test_file_result_flagged_pages`: Create FileResult with mix of good/flagged pages, verify flagged_pages property filters correctly
- `test_batch_result_to_json`: Create BatchResult with files, verify to_json produces valid JSON (json.loads roundtrip)
- `test_batch_result_counts`: Verify success_count, error_count, flagged_count properties
- `test_enum_serialization`: Verify OCREngine and PageStatus serialize as strings in to_dict output

**tests/test_processor.py — Test PDF processor with context managers:**

Test cases (all use `sample_pdf` or `empty_pdf` fixture):
- `test_extract_text`: Extract text from sample_pdf, verify contains "test content"
- `test_extract_text_by_page`: Extract by page, verify returns list of 2 items, each with correct content
- `test_extract_pages`: Extract page 0 only to new file, verify new file has 1 page with correct text
- `test_get_page_count`: Verify sample_pdf returns 2
- `test_extract_text_empty_pdf`: Verify empty_pdf returns empty or whitespace-only string
- `test_replace_pages`: Create two PDFs, replace page 1 of first with page 0 of second, verify result has correct content on each page
- `test_context_manager_cleanup`: Verify that after extract_text, no fitz documents are left open (check that file is not locked — on unix, just verify the method completes without resource warnings)

Use `from scholardoc_ocr.processor import PDFProcessor` in tests.
  </action>
  <verify>
Run: `pytest tests/ -v` — all tests must pass.
Run: `ruff check tests/` — must pass.
  </verify>
  <done>All unit tests pass, covering result serialization, PDF extraction, and context manager safety</done>
</task>

</tasks>

<verification>
1. `pytest tests/ -v` — all tests pass
2. `python -c "from scholardoc_ocr import BatchResult, PipelineCallback, ScholarDocError"` — public API works
3. `ruff check src/ tests/` — all clean
</verification>

<success_criteria>
- __init__.py exports all public types, callbacks, and exceptions
- test_types.py validates serialization roundtrip and properties
- test_processor.py validates PDF operations with context managers
- All tests pass with pytest
- ruff passes on all files
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-data-structures/01-03-SUMMARY.md`
</output>
