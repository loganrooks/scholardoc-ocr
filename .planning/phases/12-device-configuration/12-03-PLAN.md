---
phase: 12-device-configuration
plan: 03
type: execute
wave: 2
depends_on: ["12-01", "12-02"]
files_modified:
  - src/scholardoc_ocr/surya.py
  - src/scholardoc_ocr/pipeline.py
autonomous: true

must_haves:
  truths:
    - "surya.load_models() uses device from device.detect_device()"
    - "Logs show 'Using device: mps' (or cuda/cpu) during startup"
    - "Pipeline passes device_used to FileResult metadata"
    - "Surya fallback to CPU is logged at WARNING level"
  artifacts:
    - path: "src/scholardoc_ocr/surya.py"
      provides: "Device-aware model loading"
      contains: "detect_device"
    - path: "src/scholardoc_ocr/pipeline.py"
      provides: "Device tracking in results"
      contains: "device_used"
  key_links:
    - from: "src/scholardoc_ocr/surya.py"
      to: "src/scholardoc_ocr/device.py"
      via: "import and call"
      pattern: "from.*device.*import|device\\.detect_device"
    - from: "src/scholardoc_ocr/pipeline.py"
      to: "src/scholardoc_ocr/device.py"
      via: "device info propagation"
      pattern: "device_used"
---

<objective>
Integrate device detection into Surya model loading and pipeline execution.

Purpose: Make the pipeline explicitly use the detected device for Surya OCR,
         with proper logging and result metadata for transparency.

Output: Updated surya.py and pipeline.py using device detection infrastructure.
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-device-configuration/12-RESEARCH.md
@.planning/phases/12-device-configuration/12-01-SUMMARY.md
@.planning/phases/12-device-configuration/12-02-SUMMARY.md

Reference current implementations:
@src/scholardoc_ocr/surya.py
@src/scholardoc_ocr/pipeline.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update surya.py to use device detection</name>
  <files>src/scholardoc_ocr/surya.py</files>
  <action>
Modify surya.py:

1. Update load_models() function signature:
   ```python
   def load_models(device: str | None = None) -> tuple[dict[str, Any], str]:
   ```
   Now returns tuple of (model_dict, device_used_str)

2. Update load_models() implementation:
   - If device is None:
     a. Import detect_device from device module (lazy, inside function)
     b. Call detect_device() to get DeviceInfo
     c. Use device_info.device_type as the device string
     d. Log: "Using device: {device_type} ({device_name})"
   - If device is provided, use it directly (backward compatibility)

3. Return both model_dict and the actual device string used:
   ```python
   return model_dict, str(device_type)
   ```

4. Update SuryaError handling to include device info in details:
   ```python
   details={"device": device_str, "requested_device": device}
   ```

Note: Keep backward compatibility - if device string is passed directly, use it.
This allows explicit override for testing or when caller knows better.

Note on validation: Successful return from load_models() IS the validation - if
create_model_dict() succeeds, models are loaded correctly. No additional validation step needed.

Note on strict_gpu: This function does NOT enforce strict_gpu. Model loading should always
succeed (load on whatever device works). strict_gpu is enforced at INFERENCE time in
Plan 12-05's convert_pdf_with_fallback() - that's where GPU-required behavior matters.
  </action>
  <verify>
Run: python -c "from scholardoc_ocr.surya import load_models; import inspect; sig = inspect.signature(load_models); print(f'Signature: {sig}')"

Expected: Signature shows device parameter and return annotation is tuple[dict, str].
Verify function exists and has correct signature - actual model loading is slow and not needed
for verification (successful return from load_models() IS the model validation).
  </verify>
  <done>
surya.load_models() uses device detection and returns device_used string
  </done>
</task>

<task type="auto">
  <name>Task 2: Update pipeline.py to track device in results</name>
  <files>src/scholardoc_ocr/pipeline.py</files>
  <action>
Modify run_pipeline() in pipeline.py:

1. Update the Surya model loading section (around line 379):
   ```python
   # Load models once
   cb.on_model(ModelEvent(model_name="surya", status="loading"))
   t0 = time.time()
   model_dict, device_used = surya.load_models()  # Now returns tuple
   mps_sync()
   surya_model_load_time = time.time() - t0
   cb.on_model(ModelEvent(
       model_name="surya", status="loaded", time_seconds=surya_model_load_time
   ))
   ```

2. After Surya processing completes for each file, set device_used:
   ```python
   # Inside the Surya loop, after processing completes:
   file_result.device_used = device_used
   ```

3. For files that don't use Surya (TESSERACT or EXISTING engine), device_used remains None
   - This is intentional: Tesseract runs in subprocess (no GPU), EXISTING uses no OCR

4. Update the logging to include device info:
   ```python
   logger.info(
       "%s: Surya enhancement complete (device: %s)",
       file_result.filename, device_used,
   )
   ```

5. The device_used will automatically appear in JSON metadata via FileResult.to_dict()
  </action>
  <verify>
Run: pytest tests/test_pipeline.py -v -k "test_" --no-header -q 2>&1 | head -20

Expected: Existing pipeline tests still pass. New device_used field doesn't break anything.
  </verify>
  <done>
Pipeline tracks device_used in FileResult for files processed with Surya
  </done>
</task>

</tasks>

<verification>
1. `ruff check src/scholardoc_ocr/surya.py src/scholardoc_ocr/pipeline.py` - no lint errors
2. `ruff format --check src/scholardoc_ocr/surya.py src/scholardoc_ocr/pipeline.py` - properly formatted
3. `pytest tests/test_pipeline.py -v` - existing tests pass
4. Run with verbose to see device log: `python -c "import logging; logging.basicConfig(level=logging.INFO); from scholardoc_ocr.surya import load_models; load_models()"`
</verification>

<success_criteria>
- surya.load_models() automatically detects and uses best available device
- Logs clearly show which device is being used ("Using device: mps")
- FileResult.device_used captures which device processed Surya files
- JSON metadata includes device_used for transparency
- DEV-01 fully implemented (pipeline explicitly uses MPS on Apple Silicon)
- DEV-02 partially implemented (validation with actionable logging)
</success_criteria>

<output>
After completion, create `.planning/phases/12-device-configuration/12-03-SUMMARY.md`
</output>
