---
phase: 15-diagnostic-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scholardoc_ocr/diagnostics.py
  - src/scholardoc_ocr/types.py
autonomous: true

must_haves:
  truths:
    - "PageDiagnostics dataclass exists with all fields for both always-captured and diagnostics-gated data"
    - "SignalDisagreement and EngineDiff dataclasses exist for structured sub-data"
    - "PageResult has an optional diagnostics field that defaults to None"
    - "Existing code constructing PageResult continues to work without changes"
    - "All diagnostic dataclasses pickle successfully through ProcessPoolExecutor"
  artifacts:
    - path: "src/scholardoc_ocr/diagnostics.py"
      provides: "PageDiagnostics, SignalDisagreement, EngineDiff dataclasses + utility functions"
      exports: ["PageDiagnostics", "SignalDisagreement", "EngineDiff", "compute_signal_disagreements", "classify_struggle", "compute_engine_diff", "build_always_diagnostics"]
    - path: "src/scholardoc_ocr/types.py"
      provides: "PageResult with Optional[PageDiagnostics] field"
      contains: "diagnostics: PageDiagnostics | None = None"
  key_links:
    - from: "src/scholardoc_ocr/types.py"
      to: "src/scholardoc_ocr/diagnostics.py"
      via: "import PageDiagnostics for type annotation"
      pattern: "from .diagnostics import PageDiagnostics"
---

<objective>
Create the diagnostic data model: all dataclasses, utility functions, and the PageResult integration point.

Purpose: Establish the foundation that Plans 02 and 03 wire data into. All diagnostic types, signal disagreement detection, struggle classification, engine diffing, and the build_always_diagnostics helper must exist before pipeline wiring begins.

Output: New diagnostics.py module and modified types.py with backward-compatible PageResult.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-diagnostic-infrastructure/15-CONTEXT.md
@.planning/phases/15-diagnostic-infrastructure/15-RESEARCH.md
@src/scholardoc_ocr/types.py
@src/scholardoc_ocr/quality.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create diagnostics.py with all dataclasses and utility functions</name>
  <files>src/scholardoc_ocr/diagnostics.py</files>
  <action>
Create `src/scholardoc_ocr/diagnostics.py` as a new module containing:

**Dataclasses (use `from __future__ import annotations` and `@dataclass`):**

1. `SignalDisagreement` -- fields: `signals: list[str]`, `magnitude: float`
2. `EngineDiff` -- fields: `additions: list[str]`, `deletions: list[str]`, `substitutions: list[dict[str, str]]`, `summary: dict[str, int]`. Include `to_dict()` method.
3. `PageDiagnostics` -- all fields per CONTEXT.md decisions:
   - Always-captured: `signal_scores: dict[str, float]`, `signal_details: dict[str, dict]`, `composite_weights: dict[str, float]`, `signal_disagreements: list[SignalDisagreement]`, `has_signal_disagreement: bool`, `postprocess_counts: dict[str, int]`, `struggle_categories: list[str]`
   - Diagnostics-gated: `image_quality: dict[str, float | None] | None = None`, `tesseract_text: str | None = None`, `engine_diff: EngineDiff | None = None`
   - Include `to_dict()` method that conditionally includes gated fields only when non-None

**Utility functions:**

4. `DISAGREEMENT_THRESHOLD = 0.3` module constant

5. `compute_signal_disagreements(signal_scores: dict[str, float]) -> list[SignalDisagreement]` -- Use `itertools.combinations` to compute pairwise magnitude differences. Return all pairs (not just those above threshold). Round magnitude to 4 decimal places.

6. `classify_struggle(signal_scores, composite_score, threshold, image_quality=None, engine=None, surya_score=None) -> list[str]` -- Implement all 8 boolean detection rules per CONTEXT.md (bad_scan, character_confusion, vocabulary_miss, layout_error, language_confusion, signal_disagreement, gray_zone, surya_insufficient). Use conservative thresholds that err toward under-reporting. Each rule is independent; collect all that fire into the returned list. Use the exact thresholds from the research RESEARCH.md code examples.

7. `compute_engine_diff(tesseract_text: str, surya_text: str) -> EngineDiff` -- Use `difflib.SequenceMatcher(None, words_a, words_b).get_opcodes()` on word-split texts. Collect additions (insert ops), deletions (delete ops), and substitutions (replace ops where old and new are space-joined word spans). Include summary counts.

8. `build_always_diagnostics(qr: QualityResult, threshold: float) -> PageDiagnostics` -- Takes a QualityResult (from quality.py) and builds a PageDiagnostics with always-captured fields populated. Extracts signal_scores, signal_details from QualityResult. Determines composite_weights based on whether "confidence" is in signal_scores (0.4/0.3/0.3 with confidence, 0.55/0.45 without). Computes signal disagreements and struggle categories. Leaves postprocess_counts empty (filled later by postprocess wiring). Leaves diagnostics-gated fields as None.

**Import discipline:** Import QualityResult only inside function body or use TYPE_CHECKING to avoid circular imports (diagnostics.py should not import quality.py at module level). Use `from __future__ import annotations` for forward references.

**Serialization safety:** Use ONLY primitive types (float, int, str, bool, list, dict, None) in all dataclass fields. No numpy arrays, no PIL Images, no callables.
  </action>
  <verify>
Run `python -c "from scholardoc_ocr.diagnostics import PageDiagnostics, SignalDisagreement, EngineDiff, compute_signal_disagreements, classify_struggle, compute_engine_diff, build_always_diagnostics; print('All imports OK')"`.

Run `python -c "
import pickle
from scholardoc_ocr.diagnostics import PageDiagnostics, SignalDisagreement
d = PageDiagnostics(signal_scores={'garbled': 0.9, 'dictionary': 0.8}, signal_details={}, composite_weights={'garbled': 0.55, 'dictionary': 0.45}, signal_disagreements=[SignalDisagreement(signals=['garbled', 'dictionary'], magnitude=0.1)], has_signal_disagreement=False, postprocess_counts={}, struggle_categories=[])
data = pickle.dumps(d)
d2 = pickle.loads(data)
assert d2.signal_scores == d.signal_scores
print(f'Pickle OK: {len(data)} bytes')
"` to verify pickling works.

Run `ruff check src/scholardoc_ocr/diagnostics.py` and `ruff format --check src/scholardoc_ocr/diagnostics.py`.
  </verify>
  <done>diagnostics.py exists with all 3 dataclasses, 4 utility functions, all imports succeed, pickling roundtrips, and ruff passes.</done>
</task>

<task type="auto">
  <name>Task 2: Add Optional[PageDiagnostics] field to PageResult in types.py</name>
  <files>src/scholardoc_ocr/types.py</files>
  <action>
Modify `src/scholardoc_ocr/types.py`:

1. Add import at top (use TYPE_CHECKING to avoid circular import since diagnostics.py may import from types.py):
   ```python
   from typing import TYPE_CHECKING
   if TYPE_CHECKING:
       from .diagnostics import PageDiagnostics
   ```
   Note: `from __future__ import annotations` is already present, so string annotations work.

2. Add field to PageResult dataclass AFTER the `text` field:
   ```python
   diagnostics: PageDiagnostics | None = None
   ```
   This MUST have a default of None so all existing PageResult constructors continue to work.

3. Update `PageResult.to_dict()` to conditionally include diagnostics:
   ```python
   if self.diagnostics is not None:
       d["diagnostics"] = self.diagnostics.to_dict()
   ```
   Add this after the existing `include_text` block.

Do NOT change any other fields or methods. Do NOT change FileResult, BatchResult, or any other class. The change must be purely additive.
  </action>
  <verify>
Run `pytest tests/ -x -q --timeout=30` to verify existing tests still pass (the None default means no test should break).

Run `python -c "
from scholardoc_ocr.types import PageResult, PageStatus, OCREngine
# Existing construction without diagnostics still works
p = PageResult(page_number=0, status=PageStatus.GOOD, quality_score=0.9, engine=OCREngine.TESSERACT)
assert p.diagnostics is None
d = p.to_dict()
assert 'diagnostics' not in d
print('Backward compat OK')

# Construction with diagnostics works
from scholardoc_ocr.diagnostics import PageDiagnostics
diag = PageDiagnostics(signal_scores={'garbled': 0.9}, signal_details={}, composite_weights={}, signal_disagreements=[], has_signal_disagreement=False, postprocess_counts={}, struggle_categories=[])
p2 = PageResult(page_number=0, status=PageStatus.GOOD, quality_score=0.9, engine=OCREngine.TESSERACT, diagnostics=diag)
d2 = p2.to_dict()
assert 'diagnostics' in d2
print('Diagnostics field OK')
"`.

Run `ruff check src/scholardoc_ocr/types.py`.
  </verify>
  <done>PageResult has `diagnostics: PageDiagnostics | None = None` field. Existing tests pass unchanged. to_dict() conditionally includes diagnostics when present.</done>
</task>

</tasks>

<verification>
- `python -c "from scholardoc_ocr.diagnostics import *"` imports cleanly
- `python -c "from scholardoc_ocr.types import PageResult"` imports cleanly
- `pytest tests/ -x -q --timeout=30` passes (no regressions)
- `ruff check src/scholardoc_ocr/diagnostics.py src/scholardoc_ocr/types.py` passes
- PageDiagnostics pickles and unpickles successfully
</verification>

<success_criteria>
- diagnostics.py module exists with PageDiagnostics, SignalDisagreement, EngineDiff dataclasses
- All 4 utility functions (compute_signal_disagreements, classify_struggle, compute_engine_diff, build_always_diagnostics) are implemented
- PageResult.diagnostics field exists, defaults to None, backward-compatible
- All existing tests pass without modification
- All diagnostic types serialize via pickle for ProcessPoolExecutor transport
</success_criteria>

<output>
After completion, create `.planning/phases/15-diagnostic-infrastructure/15-01-SUMMARY.md`
</output>
