---
phase: 15-diagnostic-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["15-02"]
files_modified:
  - src/scholardoc_ocr/diagnostics.py
  - src/scholardoc_ocr/pipeline.py
  - src/scholardoc_ocr/cli.py
autonomous: true

must_haves:
  truths:
    - "User can run `ocr --diagnostics file.pdf` and get per-page image quality metrics (DPI, contrast, blur_score, skew_angle) in diagnostics"
    - "For pages processed by both engines, Tesseract text is preserved before Surya overwrites it, and a structured word-level diff is computed"
    - "A JSON sidecar file `{stem}.diagnostics.json` is written alongside the output PDF containing full per-page diagnostic data"
    - "Running without --diagnostics produces the same output as before (no image analysis, no text preservation, no sidecar)"
  artifacts:
    - path: "src/scholardoc_ocr/diagnostics.py"
      provides: "analyze_image_quality function for DIAG-01"
      contains: "analyze_image_quality"
    - path: "src/scholardoc_ocr/pipeline.py"
      provides: "Diagnostics-gated features wired through pipeline + JSON sidecar output"
      contains: "diagnostics"
    - path: "src/scholardoc_ocr/cli.py"
      provides: "--diagnostics CLI flag"
      contains: "--diagnostics"
  key_links:
    - from: "src/scholardoc_ocr/pipeline.py"
      to: "src/scholardoc_ocr/diagnostics.py"
      via: "call analyze_image_quality when diagnostics enabled"
      pattern: "analyze_image_quality"
    - from: "src/scholardoc_ocr/pipeline.py"
      to: "src/scholardoc_ocr/diagnostics.py"
      via: "call compute_engine_diff for Surya-processed pages"
      pattern: "compute_engine_diff"
    - from: "src/scholardoc_ocr/cli.py"
      to: "src/scholardoc_ocr/pipeline.py"
      via: "pass diagnostics=True in PipelineConfig"
      pattern: "diagnostics"
---

<objective>
Add the --diagnostics-gated features: image quality analysis (DIAG-01), Tesseract text preservation and engine diff (DIAG-04), CLI flag, and JSON diagnostic sidecar output (DIAG-08).

Purpose: Complete Phase 15 by enabling rich diagnostic output when users opt in via --diagnostics. This provides the full measurement apparatus: image quality metrics reveal scan problems, engine diffs show what Surya changed, and the JSON sidecar makes all data accessible for downstream analysis (Phase 17-19).

Output: Modified diagnostics.py with image analysis, modified pipeline.py with gated features and sidecar output, modified cli.py with --diagnostics flag.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-diagnostic-infrastructure/15-CONTEXT.md
@.planning/phases/15-diagnostic-infrastructure/15-RESEARCH.md
@.planning/phases/15-diagnostic-infrastructure/15-01-SUMMARY.md
@.planning/phases/15-diagnostic-infrastructure/15-02-SUMMARY.md
@src/scholardoc_ocr/diagnostics.py
@src/scholardoc_ocr/pipeline.py
@src/scholardoc_ocr/cli.py
@src/scholardoc_ocr/types.py
@src/scholardoc_ocr/batch.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add image quality analysis to diagnostics.py and --diagnostics flag to CLI + PipelineConfig</name>
  <files>src/scholardoc_ocr/diagnostics.py, src/scholardoc_ocr/cli.py, src/scholardoc_ocr/pipeline.py</files>
  <action>
**In `src/scholardoc_ocr/diagnostics.py`:**

Add `analyze_image_quality(pdf_path: Path, page_num: int) -> dict[str, float | None]` function:
- Open PDF with `fitz.open(pdf_path)`, get page by page_num
- DPI: Call `page.get_image_info()`. If images exist, compute average xres. If no embedded images, return None for DPI.
- Render page at 150 DPI (NOT 300 -- saves 4x memory): `page.get_pixmap(dpi=150)`
- Convert pixmap to numpy array: `np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.h, pix.w, pix.n)`
- Convert to grayscale: `cv2.cvtColor(img[:, :, :3], cv2.COLOR_RGB2GRAY)` if n>=3, else `img[:, :, 0]`
- Blur score: `float(cv2.Laplacian(gray, cv2.CV_64F).var())` -- lower = blurrier
- Contrast: `float(np.std(gray)) / 255.0` -- 0 to ~0.3 typically
- Skew angle: Implement `_detect_skew(gray)` helper using `cv2.Canny` + `cv2.HoughLinesP`. Filter to near-horizontal lines (|angle| < 45 degrees), return median angle. Return None if no lines detected.
- Return dict with `dpi`, `contrast` (rounded 4 places), `blur_score` (rounded 2 places), `skew_angle` (rounded 2 places or None)
- Imports (cv2, numpy, fitz) should be at module top since they're already available as transitive deps. But if there's concern about import weight for non-diagnostics runs, import cv2 and numpy inside the function body.

**In `src/scholardoc_ocr/pipeline.py`:**

Add `diagnostics: bool = False` field to `PipelineConfig` dataclass.

Add `"diagnostics"` to the `config_dict` that gets passed to `_tesseract_worker` (around line 271-279):
```python
"diagnostics": config.diagnostics,
```

**In `src/scholardoc_ocr/cli.py`:**

Add `--diagnostics` argument to the argument parser, after the `--extract-text` argument:
```python
parser.add_argument(
    "--diagnostics",
    action="store_true",
    help="Capture rich diagnostic data (image quality, engine diffs) and write .diagnostics.json sidecar",
)
```

Pass it to PipelineConfig:
```python
config = PipelineConfig(
    ...
    diagnostics=args.diagnostics,
)
```
  </action>
  <verify>
Run `python -c "from scholardoc_ocr.diagnostics import analyze_image_quality; print('Import OK')"`.

Run `python -c "
from scholardoc_ocr.pipeline import PipelineConfig
c = PipelineConfig()
assert hasattr(c, 'diagnostics')
assert c.diagnostics is False
print('PipelineConfig OK')
"`.

Run `python -c "
import subprocess
result = subprocess.run(['python', '-m', 'scholardoc_ocr.cli', '--help'], capture_output=True, text=True)
assert '--diagnostics' in result.stdout
print('CLI flag OK')
"`.

Run `ruff check src/scholardoc_ocr/diagnostics.py src/scholardoc_ocr/cli.py src/scholardoc_ocr/pipeline.py`.
  </verify>
  <done>analyze_image_quality function exists in diagnostics.py. PipelineConfig has diagnostics field. CLI has --diagnostics flag. All lint passes.</done>
</task>

<task type="auto">
  <name>Task 2: Wire diagnostics-gated features through pipeline and write JSON sidecar</name>
  <files>src/scholardoc_ocr/pipeline.py</files>
  <action>
Wire DIAG-01 (image quality), DIAG-04 (text preservation + diff), and DIAG-08 (JSON sidecar) through the pipeline, all gated behind `config_dict["diagnostics"]`.

**DIAG-01: Image quality in `_tesseract_worker`:**

When `config_dict.get("diagnostics", False)` is True, after building the always-captured diagnostics for each page, call `analyze_image_quality(input_path, page_number)` and set `diag.image_quality = result`. Wrap in try/except -- if image analysis fails for a page, log warning and leave image_quality as None.

Import `analyze_image_quality` from `.diagnostics` (lazy, inside function body).

**DIAG-04: Tesseract text preservation in `run_pipeline`:**

CRITICAL TIMING: Tesseract text must be captured BEFORE `map_results_to_files()` mutates `page_result.text` in-place.

When `config.diagnostics` is True, BEFORE the `map_results_to_files(sub_batch, surya_markdown, analyzer)` call in the Surya batch loop:

```python
if config.diagnostics:
    # Preserve Tesseract text before Surya overwrites it
    for fp in sub_batch:
        page_result = fp.file_result.pages[fp.page_number]
        if page_result.diagnostics is not None and page_result.text is not None:
            page_result.diagnostics.tesseract_text = page_result.text
```

Then AFTER `map_results_to_files()` returns (Surya text is now in page_result.text), compute the engine diff:

```python
if config.diagnostics:
    from .diagnostics import compute_engine_diff
    for fp in sub_batch:
        page_result = fp.file_result.pages[fp.page_number]
        if (page_result.diagnostics is not None
            and page_result.diagnostics.tesseract_text is not None
            and page_result.text is not None):
            page_result.diagnostics.engine_diff = compute_engine_diff(
                page_result.diagnostics.tesseract_text, page_result.text
            )
```

**DIAG-08: JSON diagnostic sidecar output:**

After the existing JSON metadata file writing section (around line 587-593), when `config.diagnostics` is True, write a diagnostic sidecar for each successful file:

```python
if config.diagnostics:
    import datetime
    for file_result in file_results:
        if file_result.success and file_result.output_path:
            stem = Path(file_result.output_path).stem
            sidecar = {
                "version": "1.0",
                "filename": file_result.filename,
                "generated_at": datetime.datetime.now(datetime.timezone.utc).isoformat(),
                "pipeline_config": {
                    "quality_threshold": config.quality_threshold,
                    "diagnostics": True,
                },
                "pages": [],
            }
            for page in file_result.pages:
                page_data = {
                    "page_number": page.page_number,
                    "quality_score": page.quality_score,
                    "engine": str(page.engine),
                    "flagged": page.flagged,
                    "status": str(page.status),
                }
                if page.diagnostics is not None:
                    page_data["diagnostics"] = page.diagnostics.to_dict()
                sidecar["pages"].append(page_data)

            sidecar_path = final_dir / f"{stem}.diagnostics.json"
            sidecar_path.write_text(
                json.dumps(sidecar, indent=2, default=str),
                encoding="utf-8",
            )
```

Per CONTEXT.md locked decision: sidecar goes alongside output PDF in final_dir, named `{stem}.diagnostics.json`, one per PDF.

**Error resilience throughout:** All diagnostic operations (image analysis, text preservation, diff computation, sidecar writing) should be wrapped in try/except with logging. Diagnostic failures must never break the pipeline. Log warnings and continue.
  </action>
  <verify>
Run `pytest tests/ -x -q --timeout=30` to verify no regressions.

Run `ruff check src/scholardoc_ocr/pipeline.py`.

Manual verification approach (if test PDFs exist):
```bash
# Test with diagnostics enabled
python -m scholardoc_ocr.cli --diagnostics --extract-text /path/to/test.pdf -o /tmp/diag_test

# Check sidecar exists
ls /tmp/diag_test/final/*.diagnostics.json

# Inspect sidecar content
python -c "
import json
with open('/tmp/diag_test/final/test.diagnostics.json') as f:
    data = json.load(f)
    print(f'Version: {data[\"version\"]}')
    print(f'Pages: {len(data[\"pages\"])}')
    p0 = data['pages'][0]
    if 'diagnostics' in p0:
        d = p0['diagnostics']
        print(f'Signal scores: {d.get(\"signal_scores\", {})}')
        print(f'Image quality: {d.get(\"image_quality\", \"not present\")}')
        print(f'Struggle cats: {d.get(\"struggle_categories\", [])}')
"
```
  </verify>
  <done>
DIAG-01: Image quality metrics (DPI, contrast, blur_score, skew_angle) computed and attached to diagnostics when --diagnostics enabled.
DIAG-04: Tesseract text preserved before Surya overwrite; structured word-level diff (additions, deletions, substitutions) computed for dual-engine pages.
DIAG-08: JSON sidecar `{stem}.diagnostics.json` written alongside output PDF with version, config, and full per-page diagnostic breakdown.
All gated behind --diagnostics flag. Pipeline works identically without flag. Existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `pytest tests/ -x -q --timeout=30` passes (no regressions)
- `ruff check src/scholardoc_ocr/diagnostics.py src/scholardoc_ocr/pipeline.py src/scholardoc_ocr/cli.py` passes
- `ocr --help` shows `--diagnostics` flag
- PipelineConfig.diagnostics defaults to False
- When diagnostics disabled: no image analysis, no text preservation, no sidecar (identical to pre-Phase-15 behavior)
- When diagnostics enabled: sidecar file written with image_quality, engine_diff data for applicable pages
</verification>

<success_criteria>
- DIAG-01: Image quality metrics (DPI, contrast, blur, skew) in diagnostic output when --diagnostics enabled
- DIAG-04: Tesseract text preserved before Surya overwrite; structured diff computed for dual-engine pages
- DIAG-08: `{stem}.diagnostics.json` sidecar written alongside output PDF with full per-page breakdown
- --diagnostics CLI flag works and propagates through PipelineConfig to pipeline behavior
- Without --diagnostics, pipeline behavior is identical to before Phase 15
- All 8 DIAG requirements satisfied across Plans 01-03
</success_criteria>

<output>
After completion, create `.planning/phases/15-diagnostic-infrastructure/15-03-SUMMARY.md`
</output>
