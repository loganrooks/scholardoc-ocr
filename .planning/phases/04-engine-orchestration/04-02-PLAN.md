---
phase: 04-engine-orchestration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/scholardoc_ocr/cli.py
  - src/scholardoc_ocr/__init__.py
autonomous: true

must_haves:
  truths:
    - "CLI wraps run_pipeline() and formats BatchResult for display"
    - "CLI has --force-surya flag separate from --force"
    - "CLI exit code is 0 on success, 1 on errors"
    - "run_pipeline and PipelineConfig exported from package __init__.py"
  artifacts:
    - path: "src/scholardoc_ocr/cli.py"
      provides: "CLI presentation layer wrapping library API"
      contains: "force_surya"
    - path: "src/scholardoc_ocr/__init__.py"
      provides: "Public API exports including pipeline"
      contains: "run_pipeline"
  key_links:
    - from: "src/scholardoc_ocr/cli.py"
      to: "src/scholardoc_ocr/pipeline.py"
      via: "run_pipeline(config, callback) -> BatchResult"
      pattern: "run_pipeline"
---

<objective>
Update CLI to use the rewritten pipeline API, add --force-surya flag, format BatchResult output, and export pipeline API from package.

Purpose: Separates presentation from orchestration (ARCH-01). CLI becomes a thin wrapper that calls run_pipeline() and prints results. Library users can call run_pipeline() directly.

Output: Updated cli.py with --force-surya and BatchResult formatting. Updated __init__.py with pipeline exports.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-engine-orchestration/04-01-SUMMARY.md

@src/scholardoc_ocr/cli.py
@src/scholardoc_ocr/__init__.py
@src/scholardoc_ocr/types.py
@src/scholardoc_ocr/callbacks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CLI with --force-surya and BatchResult formatting</name>
  <files>src/scholardoc_ocr/cli.py</files>
  <action>
Update cli.py:

1. Add `--force-surya` argument:
   ```python
   parser.add_argument(
       "--force-surya",
       action="store_true",
       help="Force Surya OCR on all pages regardless of quality.",
   )
   ```

2. Pass `force_surya=args.force_surya` to PipelineConfig.

3. After `run_pipeline()` returns `BatchResult`, add a `_print_summary(batch: BatchResult)` function that prints:
   - Total files processed, success count, error count
   - Files with Surya enhancement (files that have pages with engine=SURYA)
   - Per-file summary: filename, page count, quality score, engine used, time
   - For debug mode: per-page breakdown for flagged files (page number, quality score, engine)
   - Output directory location

4. Set exit code: `sys.exit(0 if batch.error_count == 0 else 1)`

5. Remove any remaining `print()` calls that duplicate pipeline logging. The CLI should only print the final summary, not inline progress (that's the callback's job).

6. Import `BatchResult` from types for type annotation in `_print_summary`.

Keep all existing arguments (input_dir, -o, -q, --force, --debug, -s, -w, -f, -r, -v). The `--force` flag maps to `force_tesseract` (existing behavior). The new `--force-surya` is separate.
  </action>
  <verify>
Run `ruff check src/scholardoc_ocr/cli.py` — no errors.
Run `python -c "from scholardoc_ocr.cli import main; print('OK')"` — imports.
Verify `--force-surya` argument exists: `grep "force.surya" src/scholardoc_ocr/cli.py`.
  </verify>
  <done>
CLI updated with --force-surya flag, BatchResult summary formatting, and proper exit codes. CLI is a thin wrapper around run_pipeline().
  </done>
</task>

<task type="auto">
  <name>Task 2: Export pipeline API from package __init__.py</name>
  <files>src/scholardoc_ocr/__init__.py</files>
  <action>
Add pipeline exports to __init__.py:

1. Add import: `from .pipeline import PipelineConfig, run_pipeline`
2. Add to `__all__`: `"PipelineConfig"`, `"run_pipeline"`

This enables library usage:
```python
from scholardoc_ocr import run_pipeline, PipelineConfig
result = run_pipeline(PipelineConfig(input_dir=Path("./scans")))
```
  </action>
  <verify>
Run `python -c "from scholardoc_ocr import run_pipeline, PipelineConfig; print('OK')"` — imports.
  </verify>
  <done>
run_pipeline and PipelineConfig exported from package top-level for library usage.
  </done>
</task>

</tasks>

<verification>
- `ruff check src/scholardoc_ocr/cli.py src/scholardoc_ocr/__init__.py` passes
- `python -c "from scholardoc_ocr import run_pipeline, PipelineConfig"` imports
- `grep "force.surya" src/scholardoc_ocr/cli.py` matches
- `grep "run_pipeline" src/scholardoc_ocr/__init__.py` matches
</verification>

<success_criteria>
CLI wraps library API with --force-surya flag and BatchResult formatting. Pipeline API exported from package for programmatic use. Exit codes reflect batch success/failure.
</success_criteria>

<output>
After completion, create `.planning/phases/04-engine-orchestration/04-02-SUMMARY.md`
</output>
